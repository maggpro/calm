<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover">
  <meta name="theme-color" content="#111111" media="(prefers-color-scheme: dark)">
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Calm — дыхание, журнал</title>
  
  <!-- PWA -->
  <link rel="manifest" href="./manifest.webmanifest">
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  
  <!-- Custom CSS -->
  <style>
    /* CSS Variables with beautiful gradients */
    :root {
      --bg: #fafbfc;
      --fg: #1a1a1a;
      --muted: #6b7280;
      --primary: #667eea;
      --card: #ffffff;
      --border: #e5e7eb;
      --danger: #ef4444;
      --orb-start: #667eea;
      --orb-end: #06b6d4;
      --orb-start-rgb: 102, 126, 234;
      --orb-end-rgb: 6, 182, 212;
      --gradient-1: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --gradient-2: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --gradient-3: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
      --gradient-4: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
      --gradient-5: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.08);
      --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.12);
      --shadow-strong: 0 20px 60px rgba(0, 0, 0, 0.15);
    }
    
    @media (prefers-color-scheme: dark) {
      :root {
        --bg: #0a0a0c;
        --fg: #f8f9fa;
        --muted: #9ca3af;
        --primary: #7ab2ff;
        --card: #1a1a1e;
        --border: #2d2d32;
        --danger: #f87171;
        --orb-start: #3b82f6;
        --orb-end: #10b981;
        --gradient-1: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        --gradient-2: linear-gradient(135deg, #ec4899 0%, #f97316 100%);
        --gradient-3: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        --gradient-4: linear-gradient(135deg, #10b981 0%, #059669 100%);
        --gradient-5: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.3);
        --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.4);
        --shadow-strong: 0 20px 60px rgba(0, 0, 0, 0.5);
      }
    }
    
    /* Global styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      background-color: var(--bg);
      color: var(--fg);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      min-height: 100vh;
      padding-bottom: 80px;
    }
    
    /* Lock scroll in focus mode */
    body.focus-mode { overflow: hidden; }
    
    /* Header with beautiful gradient */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.7) 100%);
      border-bottom: 1px solid var(--border);
      padding: 20px 16px;
      padding-top: calc(20px + env(safe-area-inset-top));
      z-index: 1000;
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-soft);
    }
    
    .header h1 {
      text-align: center;
      font-size: 28px;
      font-weight: 800;
      background: var(--gradient-1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 0;
    }
    
    [data-theme="dark"] .header {
      background: linear-gradient(135deg, rgba(26, 26, 30, 0.9) 0%, rgba(26, 26, 30, 0.7) 100%);
    }
    
    /* Main content */
    .main {
      margin-top: calc(80px + env(safe-area-inset-top));
      padding: 20px;
    }
    
    /* Pages */
    .page {
      display: none;
    }
    
    .page.active {
      display: block;
    }
    
    /* Cards with beautiful gradients */
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 24px;
      margin-bottom: 24px;
      box-shadow: var(--shadow-soft);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--gradient-1);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .card:hover::before {
      opacity: 1;
    }
    
    .card:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-medium);
    }
    
    .card.breathing-card {
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(6, 182, 212, 0.05) 100%);
      border: 1px solid rgba(102, 126, 234, 0.2);
    }
    
    .card.journal-card {
      background: linear-gradient(135deg, rgba(236, 72, 153, 0.05) 0%, rgba(249, 115, 22, 0.05) 100%);
      border: 1px solid rgba(236, 72, 153, 0.2);
    }
    
    .card.settings-card {
      background: linear-gradient(135deg, rgba(79, 172, 254, 0.05) 0%, rgba(0, 242, 254, 0.05) 100%);
      border: 1px solid rgba(79, 172, 254, 0.2);
    }
    
    /* Orb styles with beautiful animations */
    .orb-wrap {
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 0;
      position: relative;
    }
    
    .orb-shell {
      position: relative;
      width: 200px;
      height: 200px;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .orb {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--orb-start), var(--orb-end));
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      text-align: center;
      cursor: pointer;
      /* Мягкая внутренняя тень + внешний blur для очень мягких краев */
      box-shadow: inset 0 0 20px rgba(255,255,255,0.1), 
                  inset 0 0 40px rgba(255,255,255,0.05),
                  0 0 15px rgba(var(--orb-start-rgb), 0.3),
                  0 0 30px rgba(var(--orb-start-rgb), 0.2);
      filter: blur(0.5px);
      position: relative;
      overflow: hidden;
      transform: scale(1);
      transition: none;
      /* очень мягкая прозрачность к краям - агрессивный переход */
      -webkit-mask-image: radial-gradient(circle at center, 
        rgba(0,0,0,1) 0%, 
        rgba(0,0,0,1) 40%, 
        rgba(0,0,0,0.9) 50%, 
        rgba(0,0,0,0.6) 60%, 
        rgba(0,0,0,0.3) 70%, 
        rgba(0,0,0,0.1) 80%, 
        rgba(0,0,0,0.02) 90%, 
        rgba(0,0,0,0) 100%);
      mask-image: radial-gradient(circle at center, 
        rgba(0,0,0,1) 0%, 
        rgba(0,0,0,1) 40%, 
        rgba(0,0,0,0.9) 50%, 
        rgba(0,0,0,0.6) 60%, 
        rgba(0,0,0,0.3) 70%, 
        rgba(0,0,0,0.1) 80%, 
        rgba(0,0,0,0.02) 90%, 
        rgba(0,0,0,0) 100%);
    }
    
    /* Focus mode styles */
    .focus-mode .orb {
      position: fixed;
      z-index: 9999;
      transition: top 0.6s ease, left 0.6s ease, transform 0.6s ease;
      /* Размер устанавливается через JavaScript, не через CSS */
      /* width: 240px; */
      /* height: 240px; */
      margin: 0;
      opacity: 1;
      visibility: visible;
      display: block;
      /* В фокус-режиме усиливаем мягкие эффекты */
      box-shadow: inset 0 0 30px rgba(255,255,255,0.15), 
                  inset 0 0 60px rgba(255,255,255,0.08),
                  0 0 25px rgba(var(--orb-start-rgb), 0.4),
                  0 0 50px rgba(var(--orb-start-rgb), 0.3);
      filter: blur(0.3px);
    }
    
    /* Hide backdrop in focus mode */
    .focus-mode .orb-backdrop { display: none !important; }
    
    .focus-mode .orb-overlay {
      z-index: 10001 !important;
      opacity: 1 !important;
      visibility: visible !important;
      display: flex !important;
      flex-direction: column !important;
      justify-content: center !important;
      align-items: center !important;
    }
    
    /* Дополнительная коррекция для текста в фокус-режиме */
    .focus-mode .phase {
      font-size: 24px;
      margin: 0 0 8px 0 !important; /* Отступ между элементами в фокусе */
      transform: translateY(5px) !important; /* Уменьшенная коррекция */
      transition: all 0.8s ease;
    }
    
    .focus-mode .timer {
      font-size: 32px;
      transform: translateY(-5px) !important; /* Уменьшенная коррекция */
      transition: all 0.8s ease;
    }
    
    /* Focus mode scaling handled via inline transform */
    
    /* Animated focus gradient */
    .focus-gradient {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none;
      background: radial-gradient(1200px 800px at 20% 30%, rgba(102,126,234,0.18), transparent 60%),
                  radial-gradient(1000px 700px at 80% 70%, rgba(6,182,212,0.18), transparent 60%),
                  radial-gradient(900px 900px at 50% 50%, rgba(240,147,251,0.12), transparent 60%);
      background-size: 120% 120%;
      animation: focusGradientShift 16s ease-in-out infinite alternate;
      opacity: 0;
      transition: opacity 0.6s ease;
    }
    
    @keyframes focusGradientShift {
      0% { background-position: 0% 0%; filter: hue-rotate(0deg) saturate(1); }
      50% { background-position: 100% 50%; filter: hue-rotate(20deg) saturate(1.2); }
      100% { background-position: 0% 100%; filter: hue-rotate(-20deg) saturate(1.1); }
    }
    
    /* Add smooth transitions to interface elements with staggered delays */
    header {
      transition: all 0.6s ease;
      transition-delay: 0.1s; /* Заголовок появляется первым */
    }
    
    .breathing-controls {
      transition: all 0.6s ease;
      transition-delay: 0.2s; /* Контролы дыхания вторыми */
    }
    
    .mode-selector {
      transition: all 0.6s ease;
      transition-delay: 0.3s; /* Селектор режима третьим */
    }
    
    .bottom-nav {
      transition: all 0.6s ease;
      transition-delay: 0.4s; /* Нижняя навигация последней */
    }
    
    /* Hide interface elements in focus mode */
    .focus-mode header,
    .focus-mode .bottom-nav,
    .focus-mode .breathing-controls,
    .focus-mode .mode-selector {
      opacity: 0;
      transform: translateY(20px);
      pointer-events: none;
      transition-delay: 0s; /* Убираем задержки при скрытии */
    }
    
    /* Ensure orb containers don't interfere in focus mode */
    /* Do NOT hide orb parents in focus mode to avoid opacity inheritance issues */
    /* .focus-mode .orb-wrap,
    .focus-mode .orb-shell {
      opacity: 0 !important;
      pointer-events: none !important;
    } */
    
    /* Full screen overlay for focus mode */
    .focus-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--bg);
      z-index: 998;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.8s ease;
    }
    
    .focus-mode .focus-overlay { display: none !important; }
    

    
    .orb::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(
        from 0deg,
        transparent,
        rgba(255, 255, 255, 0.1),
        transparent,
        rgba(255, 255, 255, 0.1),
        transparent
      );
      animation: orb-shine 3s linear infinite;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .orb:hover::before { opacity: 0; }
    
    .orb:hover { box-shadow: none; }
    

    
    .orb-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      gap: 0px;
      width: 100%;
      padding: 0;
      color: white;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      z-index: 2;
      text-align: center;
    }
    
    .phase {
      font-size: 15px;
      font-weight: 600;
      margin: 0 0 4px 0; /* Небольшой отступ снизу */
      padding: 0;
      line-height: 1;
      opacity: 1;
      transform: translateY(2px); /* Уменьшенная коррекция */
      transition: all 0.3s ease;
    }
    
    .timer {
      font-size: 24px;
      font-weight: 700;
      font-family: monospace;
      margin: 0;
      padding: 0;
      line-height: 1;
      opacity: 1;
      transform: translateY(-2px); /* Уменьшенная коррекция */
      transition: all 0.3s ease;
    }
    
    /* Orb animations */
    @keyframes orb-shine {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    

    
    /* Orb backdrop removed */
    .orb-backdrop { display: none !important; }
    
    @keyframes backdrop-pulse {
      0%, 100% { 
        transform: scale(1);
        opacity: 0.3;
      }
      50% { 
        transform: scale(1.2);
        opacity: 0.6;
      }
    }
    
    /* Air particles animation */
    .orb::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: 
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.3) 2px, transparent 2px),
        radial-gradient(circle at 80% 30%, rgba(255, 255, 255, 0.2) 1px, transparent 1px),
        radial-gradient(circle at 40% 70%, rgba(255, 255, 255, 0.25) 1.5px, transparent 1.5px),
        radial-gradient(circle at 70% 80%, rgba(255, 255, 255, 0.15) 1px, transparent 1px);
      background-size: 60px 60px, 40px 40px, 50px 50px, 30px 30px;
      animation: air-float 8s ease-in-out infinite;
      opacity: 0.6;
    }
    
    @keyframes air-float {
      0%, 100% { 
        transform: translateY(0px) scale(1);
        opacity: 0.6;
      }
      50% { 
        transform: translateY(-10px) scale(1.1);
        opacity: 0.8;
      }
    }
    
    /* Haptic Feedback CSS animations for iOS fallback */
    @keyframes haptic-inhale {
      0%, 100% { transform: scale(1); }
      25% { transform: scale(1.001); }
      50% { transform: scale(1.002); }
      75% { transform: scale(1.001); }
    }
    
    @keyframes haptic-exhale {
      0%, 100% { transform: scale(1); }
      20% { transform: scale(1.001); }
      40% { transform: scale(1.002); }
      60% { transform: scale(1.001); }
      80% { transform: scale(1.002); }
    }
    
    @keyframes haptic-hold {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.002); }
    }
    
    @keyframes haptic-default {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.001); }
    }
    
    /* Form elements */
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: var(--fg);
    }
    
    select, textarea, input[type="range"] {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background-color: var(--bg);
      color: var(--fg);
      font-size: 16px;
    }
    
    select {
      min-height: 48px;
    }
    
    textarea {
      min-height: 100px;
      resize: vertical;
    }
    
    input[type="range"] {
      height: 6px;
      background: var(--border);
      border-radius: 3px;
      outline: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
    }
    
    /* Volume control styles */
    .volume-label {
      display: flex;
      justify-content: center;
      margin-top: 8px;
    }
    
    #volumeLabel {
      font-size: 14px;
      color: var(--muted);
      font-weight: 500;
    }
    
    /* Buttons with beautiful gradients */
    .btn {
      padding: 14px 28px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      margin-right: 12px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
      text-transform: none;
      letter-spacing: 0.5px;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s ease;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn-primary {
      background: var(--gradient-1);
      color: white;
      box-shadow: var(--shadow-soft);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }
    
    .btn-danger {
      background: var(--gradient-2);
      color: white;
      box-shadow: var(--shadow-soft);
    }
    
    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }
    
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
    }
    
    /* Toggle switches */
    .toggle {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    
    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border);
      transition: 0.4s;
      border-radius: 24px;
    }
    
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
      background-color: var(--primary);
    }
    
    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }
    
    /* Bottom navigation with beautiful design */
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(255, 255, 255, 0.9) 100%);
      border-top: 1px solid var(--border);
      padding: 12px 20px;
      z-index: 1000;
      backdrop-filter: blur(20px);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.1);
    }
    
    [data-theme="dark"] .bottom-nav {
      background: linear-gradient(135deg, rgba(26, 26, 30, 0.95) 0%, rgba(26, 26, 30, 0.9) 100%);
    }
    
    .nav-tabs {
      display: flex;
      justify-content: space-around;
      align-items: center;
    }
    
    .nav-tab {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 8px 16px;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      color: var(--muted);
      text-decoration: none;
      position: relative;
      overflow: hidden;
    }
    
    .nav-tab::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--gradient-1);
      opacity: 0;
      transition: opacity 0.3s ease;
      border-radius: 16px;
    }
    
    .nav-tab.active::before {
      opacity: 0.1;
    }
    
    .nav-tab.active {
      color: var(--primary);
      transform: translateY(-2px);
    }
    
    .nav-tab:hover {
      transform: translateY(-2px);
      color: var(--primary);
    }
    
    .nav-tab-icon {
      font-size: 20px;
      margin-bottom: 4px;
      position: relative;
      z-index: 1;
    }
    
    .nav-tab-text {
      font-size: 11px;
      font-weight: 600;
      position: relative;
      z-index: 1;
    }
    
    /* Grid */
    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }
    
    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
      
      .orb-shell {
        width: 150px;
        height: 150px;
      }
      
      .main {
        padding: 16px;
      }
      
      .card {
        padding: 16px;
      }
    }
    
    /* Typography */
    h1, h2, h3 {
      color: var(--fg);
      margin-bottom: 16px;
    }
    
    h1 {
      font-size: 28px;
      font-weight: 700;
    }
    
    h2 {
      font-size: 20px;
      font-weight: 600;
    }
    
    /* Lists */
    .list {
      list-style: none;
    }
    
    .list-item {
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
    }
    
    .list-item:last-child {
      border-bottom: none;
    }
    
    .list-item-title {
      font-weight: 500;
      margin-bottom: 4px;
    }
    
    .list-item-subtitle {
      color: var(--muted);
      font-size: 14px;
    }
    
    /* Utilities */
    .text-center {
      text-align: center;
    }
    
    .mb-20 {
      margin-bottom: 20px;
    }
    
    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <!-- Header -->
  <header class="header">
    <h1 id="pageTitle">Calm</h1>
  </header>
  
  <!-- Main content -->
  <main class="main">
         <!-- Breathing Page -->
     <div id="breath" class="page active">
       <div>
        <div class="orb-wrap" style="min-height: 50vh; display: flex; align-items: center; justify-content: center;">
          <div id="focusGradient" class="focus-gradient" aria-hidden="true"></div>
          <div class="orb-shell">
            <div id="orb" class="orb">
              <div class="orb-overlay">
                <div>
                  <div id="phase" class="phase">Готовы?</div>
                  <div id="timeLeft" class="timer">00:00</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="breathing-controls">
            <div class="form-group mode-selector">
              <label for="mode">Режим дыхания</label>
              <select id="mode">
                <option value="478">4-7-8</option>
                <option value="box">Box Breathing (4-4-4-4)</option>
                <option value="coh">Когерентное (5-5)</option>
              </select>
              <div id="modeInfo" style="margin-top: 8px; font-size: 14px; color: var(--muted);"></div>
            </div>
             
             <div class="form-group">
               <label for="minutes">Длительность: <span id="minutesLabel">3</span> мин</label>
               <input type="range" id="minutes" min="1" max="10" value="3" />
             </div>
              
             <div class="form-group">
               <button id="stopBreath" class="btn" style="display: none;">Стоп</button>
             </div>
            <div>
              <h3 style="margin: 12px 0 8px;">Подсказки</h3>
              <div id="tipsText">Следуйте подсказкам: вдох, задержка, выдох. Сфокусируйтесь на плавности.</div>
            </div>
        </div>
      </div>
     </div>
     
         <!-- Journal Page -->
     <div id="journal" class="page">
       <div class="card journal-card">
        <h2>Журнал</h2>
        <div class="grid-2">
          <div>
            <div class="form-group">
              <label for="stressLevel">Уровень стресса: <strong><span id="stressLevelLabel">5</span>/10</strong></label>
              <input type="range" id="stressLevel" min="1" max="10" value="5" />
            </div>
            
            <div class="form-group">
              <label for="note">Заметка</label>
              <textarea id="note" placeholder="Коротко опишите своё состояние..."></textarea>
            </div>
            
            <div class="form-group">
              <button id="saveEntry" class="btn btn-primary">Сохранить</button>
              <button id="clearEntries" class="btn btn-danger">Удалить всё</button>
            </div>
          </div>
          
          <div>
            <h3>История</h3>
            <ul id="entries" class="list"></ul>
          </div>
        </div>
      </div>
    </div>
    
         <!-- Settings Page -->
     <div id="settings" class="page">
       <div class="card settings-card">
        <h2>Настройки</h2>
        <div class="grid-2">
          <div>
            <div class="form-group">
              <label for="vibrationToggle">Вибрация</label>
              <label class="toggle">
                <input type="checkbox" id="vibrationToggle" />
                <span class="toggle-slider"></span>
              </label>
            </div>
            
            <div class="form-group">
              <label for="voiceToggle">Голосовые подсказки</label>
              <label class="toggle">
                <input type="checkbox" id="voiceToggle" />
                <span class="toggle-slider"></span>
              </label>
            </div>
            
            <div class="form-group">
              <label for="musicToggle">Музыка</label>
              <label class="toggle">
                <input type="checkbox" id="musicToggle" />
                <span class="toggle-slider"></span>
              </label>
            </div>
            
            <div class="form-group" id="volumeControl" style="display: none;">
              <label for="volumeSlider">Громкость</label>
              <input type="range" id="volumeSlider" min="0" max="100" value="50" />
              <div class="volume-label">
                <span id="volumeLabel">50%</span>
              </div>
            </div>
            
            <div class="form-group">
              <label for="themeSelect">Тема</label>
              <select id="themeSelect">
                <option value="auto">Авто</option>
                <option value="light">Светлая</option>
                <option value="dark">Тёмная</option>
              </select>
            </div>
            
            <div class="form-group">
              <label for="langSelect">Язык</label>
              <select id="langSelect">
                <option value="ru">Русский</option>
                <option value="en">English</option>
                <option value="es">Español</option>
                <option value="ja">日本語</option>
                <option value="zh">中文</option>
              </select>
            </div>
          </div>
          
          <div>
            <div class="card">
              <p id="persistNote">
                Настройки сохраняются локально и применяются при следующем запуске.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
  
  <!-- Bottom Navigation -->
  <nav class="bottom-nav">
    <div class="nav-tabs">
      <a href="#" class="nav-tab active" data-tab="breath">
        <div class="nav-tab-icon">🫁</div>
        <div class="nav-tab-text">Дыхание</div>
      </a>
      <a href="#" class="nav-tab" data-tab="journal">
        <div class="nav-tab-icon">📖</div>
        <div class="nav-tab-text">Журнал</div>
      </a>
      <a href="#" class="nav-tab" data-tab="settings">
        <div class="nav-tab-icon">⚙️</div>
        <div class="nav-tab-text">Настройки</div>
      </a>
    </div>
  </nav>

  <!-- JavaScript -->
  <script>
    // ================= I18N =================
    const I18N = {
      ru: {
        app: 'Calm',
        title: 'Calm — дыхание, журнал',
        tabs: { breath: 'Дыхание', journal: 'Журнал', settings: 'Настройки' },
        phases: { inhale: 'Вдох', exhale: 'Выдох', hold: 'Задержка', pause: 'Пауза', ready: 'Готовы?' },
        breathing: { title: 'Дыхание', mode: 'Режим дыхания', duration: 'Длительность', stop: 'Стоп', tips: 'Следуйте подсказкам: вдох, задержка, выдох. Сфокусируйтесь на плавности.' },

        journal: { title: 'Журнал', level: 'Уровень стресса', note: 'Заметка', save: 'Сохранить', clear: 'Удалить всё', empty: 'Пока нет записей', history: 'История', note_placeholder: 'Коротко опишите своё состояние...', confirm_clear: 'Удалить все записи?' },
        settings: { title: 'Настройки', vibration: 'Вибрация', voice: 'Голосовые подсказки', music: 'Музыка', volume: 'Громкость', theme: 'Тема', theme_auto: 'Авто', theme_light: 'Светлая', theme_dark: 'Тёмная', lang: 'Язык', persist_note: 'Настройки сохраняются локально и применяются при следующем запуске.' }
      },
      en: {
        app: 'Calm',
        title: 'Calm — breathing, journal',
        tabs: { breath: 'Breathing', journal: 'Journal', settings: 'Settings' },
        phases: { inhale: 'Inhale', exhale: 'Exhale', hold: 'Hold', pause: 'Pause', ready: 'Ready?' },
        breathing: { title: 'Breathing', mode: 'Breathing mode', duration: 'Duration', start: 'Start', stop: 'Stop', panic: 'Panic', tips: 'Follow the prompts: inhale, hold, exhale. Focus on smoothness.' },

        journal: { title: 'Journal', level: 'Stress level', note: 'Note', save: 'Save', clear: 'Clear all', empty: 'No entries yet', history: 'History', note_placeholder: 'Briefly describe how you feel...', confirm_clear: 'Delete all entries?' },
        settings: { title: 'Settings', vibration: 'Vibration', voice: 'Voice prompts', music: 'Music', volume: 'Volume', theme: 'Theme', theme_auto: 'Auto', theme_light: 'Light', theme_dark: 'Dark', lang: 'Language', persist_note: 'Settings are saved locally and applied on next launch.' }
      },
      es: {
        app: 'Calm',
        title: 'Calm — respiración, diario',
        tabs: { breath: 'Respirar', journal: 'Diario', settings: 'Ajustes' },
        phases: { inhale: 'Inhala', exhale: 'Exhala', hold: 'Mantén', pause: 'Pausa', ready: '¿Listo?' },
        breathing: { title: 'Respirar', mode: 'Modo de respiración', duration: 'Duración', start: 'Iniciar', stop: 'Detener', panic: 'Pánico', tips: 'Sigue las indicaciones: inhala, retén, exhala. Enfócate en la suavidad.' },

        journal: { title: 'Diario', level: 'Nivel de estrés', note: 'Nota', save: 'Guardar', clear: 'Borrar todo', empty: 'Aún no hay entradas', history: 'Historial', note_placeholder: 'Describe brevemente cómo te sientes...', confirm_clear: '¿Borrar todas las entradas?' },
        settings: { title: 'Ajustes', vibration: 'Vibración', voice: 'Indicaciones de voz', music: 'Música', volume: 'Volumen', theme: 'Tema', theme_auto: 'Auto', theme_light: 'Claro', theme_dark: 'Oscuro', lang: 'Idioma', persist_note: 'Los ajustes se guardan localmente y se aplican en el próximo inicio.' }
      },
      ja: {
        app: 'Calm',
        title: 'Calm — 呼吸、日記',
        tabs: { breath: '呼吸', journal: '日記', settings: '設定' },
        phases: { inhale: '吸う', exhale: '吐く', hold: '止める', pause: '休憩', ready: '準備完了？' },
        breathing: { title: '呼吸', mode: '呼吸モード', duration: '時間', start: '開始', stop: '停止', panic: 'パニック', tips: '指示に従ってください：吸う、止める、吐く。滑らかさに集中してください。' },

        journal: { title: '日記', level: 'ストレスレベル', note: 'メモ', save: '保存', clear: 'すべて削除', empty: 'まだエントリがありません', history: '履歴', note_placeholder: 'あなたの気持ちを簡単に説明してください...', confirm_clear: 'すべてのエントリを削除しますか？' },
        settings: { title: '設定', vibration: '振動', voice: '音声プロンプト', music: '音楽', volume: '音量', theme: 'テーマ', theme_auto: '自動', theme_light: '明るい', theme_dark: '暗い', lang: '言語', persist_note: '設定はローカルに保存され、次回起動時に適用されます。' }
      },
      zh: {
        app: 'Calm',
        title: 'Calm — 呼吸、日记',
        tabs: { breath: '呼吸', journal: '日记', settings: '设置' },
        phases: { inhale: '吸气', exhale: '呼气', hold: '屏气', pause: '暂停', ready: '准备好了吗？' },
        breathing: { title: '呼吸', mode: '呼吸模式', duration: '时长', start: '开始', stop: '停止', panic: '恐慌', tips: '按照提示：吸气、屏气、呼气。专注于流畅性。' },

        journal: { title: '日记', level: '压力水平', note: '备注', save: '保存', clear: '清除全部', empty: '还没有条目', history: '历史', note_placeholder: '简要描述你的感受...', confirm_clear: '删除所有条目？' },
        settings: { title: '设置', vibration: '振动', voice: '语音提示', music: '音乐', volume: '音量', theme: '主题', theme_auto: '自动', theme_light: '浅色', theme_dark: '深色', lang: '语言', persist_note: '设置保存在本地，下次启动时应用。' }
      }
    };
    
    // ================= LANGUAGE MANAGEMENT =================
    let currentLang = 'ru';
    
    function setLanguage(lang) {
      currentLang = lang;
      document.documentElement.lang = lang;
      document.title = I18N[lang].title;
      applyI18n();
    }
    
    function applyI18n() {
      // Безопасная функция для установки textContent
      function safeSetText(selector, text) {
        const element = document.querySelector(selector);
        if (element) {
          element.textContent = text;
        }
      }
      
      function safeSetTextById(id, text) {
        const element = document.getElementById(id);
        if (element) {
          element.textContent = text;
        }
      }
      
      // Update page title
      safeSetTextById('pageTitle', I18N[currentLang].app);
      
      // Update tab labels
      const tabLabels = document.querySelectorAll('.nav-tab-text');
      if (tabLabels.length >= 3) {
        tabLabels[0].textContent = I18N[currentLang].tabs.breath;
        tabLabels[1].textContent = I18N[currentLang].tabs.journal;
        tabLabels[2].textContent = I18N[currentLang].tabs.settings;
      }
      
      // Update page titles
      safeSetText('#breath h2', I18N[currentLang].breathing.title);
      safeSetText('#journal h2', I18N[currentLang].journal.title);
      safeSetText('#settings h2', I18N[currentLang].settings.title);
      
      // Update breathing page
      safeSetText('#tipsText', I18N[currentLang].breathing.tips);
      
      // Update journal page
      safeSetText('#journal h3', I18N[currentLang].journal.history);
      
      // Update settings page
      safeSetText('#persistNote', I18N[currentLang].settings.persist_note);
      
      // Update form labels
      safeSetText('label[for="mode"]', I18N[currentLang].breathing.mode);
      safeSetText('label[for="minutes"]', I18N[currentLang].breathing.duration + ': ');
      safeSetText('label[for="stressLevel"]', I18N[currentLang].journal.level + ': ');
      safeSetText('label[for="note"]', I18N[currentLang].journal.note);
      safeSetText('label[for="vibrationToggle"]', I18N[currentLang].settings.vibration);
      safeSetText('label[for="voiceToggle"]', I18N[currentLang].settings.voice);
      safeSetText('label[for="musicToggle"]', I18N[currentLang].settings.music);
      safeSetText('label[for="volumeSlider"]', I18N[currentLang].settings.volume);
      safeSetText('label[for="themeSelect"]', I18N[currentLang].settings.theme);
      safeSetText('label[for="langSelect"]', I18N[currentLang].settings.lang);
      
      // Update button texts
      safeSetText('#startBreath', I18N[currentLang].breathing.start);
      safeSetText('#stopBreath', I18N[currentLang].breathing.stop);
      safeSetText('#panicBreath', I18N[currentLang].breathing.panic);
      safeSetText('#saveEntry', I18N[currentLang].journal.save);
      safeSetText('#clearEntries', I18N[currentLang].journal.clear);
      
      // Update placeholders
      const noteInput = document.querySelector('#note');
      if (noteInput) {
        noteInput.placeholder = I18N[currentLang].journal.note_placeholder;
      }
      
      // Update breathing mode options
      buildModeOptions();
    }
    
    function buildModeOptions() {
      const modeSelect = document.getElementById('mode');
      const modeInfo = document.getElementById('modeInfo');
      
      // Проверяем, что элементы существуют
      if (!modeSelect) {
        console.log('⚠️ Mode select not found, skipping mode options build');
        return;
      }
      
      const MODE_LABELS = {
        '478': currentLang === 'ru' ? '4-7-8' : '4-7-8',
        'box': currentLang === 'ru' ? 'Квадратное дыхание' : 'Box Breathing',
        'coh': currentLang === 'ru' ? 'Когерентное' : 'Coherent'
      };
      
      // Clear existing options
      modeSelect.innerHTML = '';
      
      // Add new options
      Object.entries(MODE_LABELS).forEach(([value, label]) => {
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        modeSelect.appendChild(option);
      });
      
      // Update mode info only if modeInfo exists
      if (modeInfo) {
        updateModeInfo();
      }
    }
    
    function updateModeInfo() {
      const modeSelect = document.getElementById('mode');
      const modeInfo = document.getElementById('modeInfo');
      
      // Проверяем, что элементы существуют
      if (!modeSelect || !modeInfo) {
        return;
      }
      
      const mode = modeSelect.value;
      
      const modeDescriptions = {
        '478': '4 секунды вдох, 7 секунд задержка, 8 секунд выдох',
        'box': '4 секунды вдох, 4 секунды задержка, 4 секунды выдох, 4 секунды пауза',
        'coh': '5 секунд вдох, 5 секунд выдох'
      };
      
      modeInfo.textContent = modeDescriptions[mode] || '';
    }
    
    // ================= BREATHING LOGIC =================
    let breathingInterval;
    let currentPhase = 'ready';
    let timeLeft = 0;
    let totalTime = 0;
    let currentScaleValue = 1; // tracks current orb scale for hold/pause
    // Particles for focus mode
    let particlesCanvas, particlesCtx, particlesAnim;
    let particlesMode = 'idle'; // inhale | exhale | hold | idle
    // Focus move trajectory storage (Point A)
    let focusStartX = null;
    let focusStartY = null;
    const FOCUS_MOVE_MS = 800; // Увеличиваем время анимации для лучшей видимости
    
    // Music variables
    let backgroundMusic = null;
    let musicVolume = 0.5;
    
    // Screen wake lock
    let wakeLock = null;
    
    // Function to log text positioning and orb state
    function logTextPosition(context) {
      const orb = document.getElementById('orb');
      const orbShell = document.querySelector('.orb-shell');
      const orbWrap = document.querySelector('.orb-wrap');
      const overlay = document.querySelector('.orb-overlay');
      const phase = document.getElementById('phase');
      const timer = document.getElementById('timeLeft');
      
      if (!orb || !overlay || !phase || !timer) return;
      
      const orbRect = orb.getBoundingClientRect();
      const overlayRect = overlay.getBoundingClientRect();
      const phaseRect = phase.getBoundingClientRect();
      const timerRect = timer.getBoundingClientRect();
      
      console.log(`📝 TEXT & ORB POSITION [${context}]:`);
      
      // Логируем состояние орба и его контейнеров
      if (orbShell) {
        const shellRect = orbShell.getBoundingClientRect();
        console.log('  🏠 Orb Shell:', Math.round(shellRect.width) + 'x' + Math.round(shellRect.height), 'at', Math.round(shellRect.left) + ',' + Math.round(shellRect.top));
      }
      if (orbWrap) {
        const wrapRect = orbWrap.getBoundingClientRect();
        console.log('  📦 Orb Wrap:', Math.round(wrapRect.width) + 'x' + Math.round(wrapRect.height), 'at', Math.round(wrapRect.left) + ',' + Math.round(wrapRect.top));
      }
      
      console.log('  🔵 Orb:', Math.round(orbRect.width) + 'x' + Math.round(orbRect.height), 'at', Math.round(orbRect.left) + ',' + Math.round(orbRect.top));
      console.log('  🎨 Orb CSS styles:');
      console.log('    position:', orb.style.position || 'default');
      console.log('    top:', orb.style.top || 'default');
      console.log('    left:', orb.style.left || 'default');
      console.log('    transform:', orb.style.transform || 'default');
      console.log('    width:', orb.style.width || 'default');
      console.log('    height:', orb.style.height || 'default');
      
      console.log('  📄 Overlay:', Math.round(overlayRect.width) + 'x' + Math.round(overlayRect.height), 'at', Math.round(overlayRect.left) + ',' + Math.round(overlayRect.top));
      console.log('  📝 Phase text:', '"' + phase.textContent + '"', Math.round(phaseRect.width) + 'x' + Math.round(phaseRect.height), 'at', Math.round(phaseRect.left) + ',' + Math.round(phaseRect.top));
      console.log('  ⏰ Timer text:', '"' + timer.textContent + '"', Math.round(timerRect.width) + 'x' + Math.round(timerRect.height), 'at', Math.round(timerRect.left) + ',' + Math.round(timerRect.top));
      
      // Проверяем центрирование
      const orbCenterX = orbRect.left + orbRect.width / 2;
      const orbCenterY = orbRect.top + orbRect.height / 2;
      const phaseCenterX = phaseRect.left + phaseRect.width / 2;
      const phaseCenterY = phaseRect.top + phaseRect.height / 2;
      const timerCenterX = timerRect.left + timerRect.width / 2;
      const timerCenterY = timerRect.top + timerRect.height / 2;
      
      console.log('  🎯 Orb center:', Math.round(orbCenterX) + ',' + Math.round(orbCenterY));
      console.log('  🎯 Phase center:', Math.round(phaseCenterX) + ',' + Math.round(phaseCenterY), '(offset:', Math.round(phaseCenterX - orbCenterX) + ',' + Math.round(phaseCenterY - orbCenterY) + ')');
      console.log('  🎯 Timer center:', Math.round(timerCenterX) + ',' + Math.round(timerCenterY), '(offset:', Math.round(timerCenterX - orbCenterX) + ',' + Math.round(timerCenterY - orbCenterY) + ')');
      
      // Проверяем, в каком режиме находится орб
      const isFocusMode = document.body.classList.contains('focus-mode');
      const orbParent = orb.parentNode;
      console.log('  🔄 Focus mode:', isFocusMode);
      console.log('  👨‍👩‍👧‍👦 Orb parent:', orbParent ? orbParent.id || orbParent.className || orbParent.tagName : 'none');
      
      // Дополнительное логирование координат для отслеживания скачков
      console.log('  📍 COORDINATES TRACKING:');
      console.log('    getBoundingClientRect():', Math.round(orbRect.left) + ',' + Math.round(orbRect.top));
      console.log('    CSS position:', orb.style.position);
      console.log('    CSS top:', orb.style.top);
      console.log('    CSS left:', orb.style.left);
      console.log('    CSS transform:', orb.style.transform);
      
      // Проверяем, не изменились ли координаты внезапно
      if (window.lastOrbPosition) {
        const deltaX = Math.abs(orbRect.left - window.lastOrbPosition.x);
        const deltaY = Math.abs(orbRect.top - window.lastOrbPosition.y);
        if (deltaX > 5 || deltaY > 5) {
          console.log('  ⚠️ ORB JUMP DETECTED!');
          console.log('    Previous position:', window.lastOrbPosition.x + ',' + window.lastOrbPosition.y);
          console.log('    Current position:', Math.round(orbRect.left) + ',' + Math.round(orbRect.top));
          console.log('    Delta:', Math.round(deltaX) + ',' + Math.round(deltaY));
        }
      }
      
      // Сохраняем текущую позицию для следующего сравнения
      window.lastOrbPosition = { x: orbRect.left, y: orbRect.top };
    }
    
    const BREATHING_PATTERNS = {
      '478': { inhale: 4, hold: 7, exhale: 8 },
      'box': { inhale: 4, hold: 4, exhale: 4, pause: 4 },
      'coh': { inhale: 5, exhale: 5 }
    };
    
    function startBreathing() {
      const mode = document.getElementById('mode').value;
      const minutes = parseInt(document.getElementById('minutes').value);
      
      if (breathingInterval) {
        clearInterval(breathingInterval);
      }
      
      const pattern = BREATHING_PATTERNS[mode];
      totalTime = minutes * 60;
      timeLeft = totalTime;
      currentScaleValue = 1;
      
      // Вычисляем точку A ДО переноса в портал (центр orb-shell)
      const shell = document.querySelector('.orb-shell');
      const sr = shell.getBoundingClientRect();
      focusStartX = sr.left + sr.width / 2;
      focusStartY = sr.top + sr.height / 2;
      
      // Отладка: проверяем стартовые координаты
      console.log('Start breathing - focusStartX:', focusStartX, 'focusStartY:', focusStartY);
      const targetX = window.innerWidth / 2; // точка B — центр экрана
      const targetY = window.innerHeight / 2;
      console.log('🎬 START ANIMATION: A→B from', focusStartX, focusStartY, 'to', targetX, targetY);
      
      const orb = document.getElementById('orb');
      
      // КРИТИЧНО: Устанавливаем позиционирование ДО перемещения в portal
      console.log('🔧 SETTING FIXED POSITION BEFORE MOVING TO PORTAL');
      console.log('  Before setting styles - orb position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      
      // Устанавливаем позицию на исходную позицию (не на центр экрана)
      orb.style.position = 'fixed';
      orb.style.top = `${focusStartY}px`;
      orb.style.left = `${focusStartX}px`;
      orb.style.transform = 'translate(-50%, -50%) scale(1)';
      
      console.log('  After setting styles - orb position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      console.log('  🎯 Target position (should stay at):', focusStartX + ',' + focusStartY);
      
      // Проверяем, что стили действительно применились
      setTimeout(() => {
        const rect = orb.getBoundingClientRect();
        console.log('  🔍 VERIFICATION - getBoundingClientRect after styles:', Math.round(rect.left) + ',' + Math.round(rect.top));
        console.log('  🔍 VERIFICATION - expected position:', Math.round(focusStartX - rect.width/2) + ',' + Math.round(focusStartY - rect.height/2));
        
        // Если позиция неправильная, исправляем её
        const expectedLeft = focusStartX - rect.width / 2;
        const expectedTop = focusStartY - rect.height / 2;
        const deltaX = Math.abs(rect.left - expectedLeft);
        const deltaY = Math.abs(rect.top - expectedTop);
        
        if (deltaX > 5 || deltaY > 5) {
          console.log('  ⚠️ POSITION CORRECTION NEEDED - delta:', Math.round(deltaX) + ',' + Math.round(deltaY));
          orb.style.left = `${expectedLeft}px`;
          orb.style.top = `${expectedTop}px`;
          
          // Проверяем исправление
          setTimeout(() => {
            const newRect = orb.getBoundingClientRect();
            console.log('  ✅ AFTER CORRECTION - getBoundingClientRect:', Math.round(newRect.left) + ',' + Math.round(newRect.top));
          }, 10);
        }
      }, 10);
      
      // Определяем размер в зависимости от экрана
      const isMobile = window.innerWidth <= 768;
      const normalSize = isMobile ? '150px' : '200px';
      const focusSize = isMobile ? '200px' : '240px';
      
      orb.style.width = normalSize; // Начинаем с обычного размера
      orb.style.height = normalSize;
      console.log('📏 START: Setting orb size to', normalSize, '(normal size)');
      orb.style.willChange = 'top, left, transform, width, height';
      orb.style.transition = `top ${FOCUS_MOVE_MS}ms ease, left ${FOCUS_MOVE_MS}ms ease, transform ${FOCUS_MOVE_MS}ms ease, width ${FOCUS_MOVE_MS}ms ease, height ${FOCUS_MOVE_MS}ms ease`;
      console.log('🎬 SETTING START TRANSITION:', orb.style.transition);
      
      logTextPosition('AFTER SETTING FIXED POSITION');
      
      // Теперь безопасно перемещаем в portal
      enterFocusMode();
      requestAnimationFrame(() => {
        console.log('🎬 TRIGGERING START ANIMATION to', targetX, targetY, '+ size increase');
        orb.style.top = `${targetY}px`;
        orb.style.left = `${targetX}px`;
        orb.style.width = focusSize; // Увеличиваем размер
        orb.style.height = focusSize;
        console.log('📏 START: Animating orb size to', focusSize, '(focus size)');
        
        // Логируем позицию текста после начала анимации
        setTimeout(() => {
          logTextPosition('DURING FOCUS ANIMATION');
        }, 100);
      });
      
      // Добавим обработчик для отслеживания завершения анимации включения
      const startAnimationHandler = (e) => {
        console.log('🎬 START ANIMATION TRANSITIONEND triggered:', e.propertyName);
      };
      orb.addEventListener('transitionend', startAnimationHandler, { once: true });
      
      // Запуск фаз после короткого ожидания, чтобы завершить перемещение
      setTimeout(() => {
        console.log('🎬 START ANIMATION TIMEOUT - starting breathing phases');
        logTextPosition('FOCUS ANIMATION COMPLETE');
        updateDisplay();
        startBreathingCycle(pattern);
        const stopButton = document.getElementById('stopBreath');
        if (stopButton) {
          stopButton.style.display = 'inline-block';
        }
        
        // Запускаем музыку при начале упражнения
        startMusic();
        
        // Предотвращаем затухание экрана
        requestWakeLock();
      }, FOCUS_MOVE_MS + 20);
    }
    
    function startBreathingCycle(pattern) {
      let phaseIndex = 0;
      const phases = Object.keys(pattern);
      
      function nextPhase() {
        if (timeLeft <= 0) {
          stopBreathing();
          return;
        }
        
        const phase = phases[phaseIndex];
        const duration = pattern[phase];
        
        currentPhase = phase;
        updatePhaseDisplay(phase, duration);
        
        // Start countdown for this phase
        let phaseTimeLeft = duration;
        
        const phaseInterval = setInterval(() => {
          phaseTimeLeft--;
          timeLeft--;
          
          // Prevent negative values
          if (phaseTimeLeft <= 0) {
            clearInterval(phaseInterval);
            phaseIndex = (phaseIndex + 1) % phases.length;
            nextPhase();
          }
          
          // Stop if total time is up
          if (timeLeft <= 0) {
            clearInterval(phaseInterval);
            stopBreathing();
            return;
          }
          
          updateDisplay();
        }, 1000);
      }
      
      nextPhase();
    }
    
    // Universal haptic feedback function (Android + iOS)
    function triggerHapticFeedback(type) {
      // Проверяем поддержку Web Vibration API (Android)
      if ('vibrate' in navigator) {
        switch (type) {
          case 'inhale':
            navigator.vibrate([200, 100, 200]);
            break;
          case 'exhale':
            navigator.vibrate([100, 50, 100, 50, 100]);
            break;
          case 'hold':
            navigator.vibrate(300);
            break;
          default:
            navigator.vibrate(100);
        }
        return;
      }
      
      // iOS Haptic Feedback - попробуем несколько способов
      let hapticTriggered = false;
      
      // Способ 1: iOS 13+ Haptic Engine
      if (window.navigator && window.navigator.vibrate) {
        try {
          // iOS поддерживает короткие вибрации
          if (type === 'inhale') {
            navigator.vibrate(50);
            setTimeout(() => navigator.vibrate(50), 100);
            setTimeout(() => navigator.vibrate(50), 200);
          } else if (type === 'exhale') {
            navigator.vibrate(30);
            setTimeout(() => navigator.vibrate(30), 50);
            setTimeout(() => navigator.vibrate(30), 100);
            setTimeout(() => navigator.vibrate(30), 150);
            setTimeout(() => navigator.vibrate(30), 200);
          } else if (type === 'hold') {
            navigator.vibrate(100);
          } else {
            navigator.vibrate(50);
          }
          hapticTriggered = true;
        } catch (e) {
          // Игнорируем ошибки
        }
      }
      
      // Способ 2: WebKit message handlers (для нативных приложений)
      if (!hapticTriggered && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.hapticFeedback) {
        try {
          window.webkit.messageHandlers.hapticFeedback.postMessage({ type: type });
          hapticTriggered = true;
        } catch (e) {
          // Игнорируем ошибки
        }
      }
      
      // Способ 3: AudioContext для создания "вибрации" через звук
      if (!hapticTriggered && window.AudioContext) {
        try {
          const audioContext = new (window.AudioContext || window.webkitAudioContext)();
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);
          
          // Настройка частоты и громкости для разных типов
          if (type === 'inhale') {
            oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.1);
          } else if (type === 'exhale') {
            oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.05);
          } else if (type === 'hold') {
            oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
            gainNode.gain.setValueAtTime(0.08, audioContext.currentTime);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
          }
          
          hapticTriggered = true;
        } catch (e) {
          // Игнорируем ошибки
        }
      }
      
      // Fallback: CSS анимации для визуальной обратной связи
      if (!hapticTriggered) {
        if (type === 'inhale') {
          document.body.style.animation = 'haptic-inhale 0.5s ease-in-out';
        } else if (type === 'exhale') {
          document.body.style.animation = 'haptic-exhale 0.3s ease-in-out';
        } else if (type === 'hold') {
          document.body.style.animation = 'haptic-hold 0.3s ease-in-out';
        } else {
          document.body.style.animation = 'haptic-default 0.2s ease-in-out';
        }
        
        // Очищаем анимацию
        setTimeout(() => {
          document.body.style.animation = '';
        }, type === 'inhale' ? 500 : type === 'exhale' ? 300 : type === 'hold' ? 300 : 200);
      }
    }
    
    function updatePhaseDisplay(phase, duration) {
      const phaseElement = document.getElementById('phase');
      const orb = document.getElementById('orb');
      
      const phaseLabels = {
        'inhale': 'Вдох',
        'exhale': 'Выдох',
        'hold': 'Задержка',
        'pause': 'Пауза'
      };
      
      // Update phase text and force re-layout to keep centered
      phaseElement.textContent = phaseLabels[phase] || phase;
      const overlay = document.querySelector('#orb .orb-overlay');
      if (overlay) { overlay.offsetHeight; }
      
      // Determine target scale by phase
      let targetScale = currentScaleValue;
      if (phase === 'inhale') {
        targetScale = 1.3;         // grow during inhale
      } else if (phase === 'hold') {
        targetScale = currentScaleValue; // freeze
      } else if (phase === 'exhale') {
        targetScale = 0.7;         // shrink during exhale
      } else if (phase === 'pause') {
        targetScale = currentScaleValue; // keep small during pause
      }
      
      // Set transition duration to match phase duration
      const durationSec = `${duration}s`;
      
      // In focus mode: drive particles + transform
      if (document.body.classList.contains('focus-mode')) {
        orb.style.transition = `transform ${durationSec} ease-in-out`;
        const baseTranslate = 'translate(-50%, -50%)';
        orb.style.transform = `${baseTranslate} scale(${targetScale})`;
        updateParticlesForPhase(phase, duration);
      } else {
        // normal mode
        orb.style.transition = `transform ${durationSec} ease-in-out`;
        orb.style.transform = `scale(${targetScale})`;
      }
      
      // remember current target for next phases
      currentScaleValue = targetScale;
      
      // Voice prompt
      if (document.getElementById('voiceToggle').checked && 'speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(phaseLabels[phase]);
        utterance.lang = currentLang === 'ru' ? 'ru-RU' : 'en-US';
        speechSynthesis.speak(utterance);
      }
      
      // Universal haptic feedback for different phases (Android + iOS)
      if (document.getElementById('vibrationToggle').checked) {
        if (phase === 'inhale') {
          // Длинная вибрация для вдоха
          triggerHapticFeedback('inhale');
        } else if (phase === 'exhale') {
          // Короткие вибрации для выдоха
          triggerHapticFeedback('exhale');
        } else if (phase === 'hold') {
          // Одна длинная вибрация для задержки
          triggerHapticFeedback('hold');
        } else {
          // Стандартная вибрация для других фаз
          triggerHapticFeedback('default');
        }
      }
    }
    
    function updateDisplay() {
      // Ensure timeLeft is never negative
      if (timeLeft < 0) {
        timeLeft = 0;
      }
      
      const minutes = Math.floor(timeLeft / 60);
      const seconds = timeLeft % 60;
      document.getElementById('timeLeft').textContent = 
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    function stopBreathing() {
      // Clear all intervals
      if (breathingInterval) {
        clearInterval(breathingInterval);
        breathingInterval = null;
      }
      
      // Clear any phase intervals that might be running
      const phaseIntervals = window.phaseIntervals || [];
      phaseIntervals.forEach(interval => clearInterval(interval));
      window.phaseIntervals = [];
      
      // Reset state
      currentPhase = 'ready';
      timeLeft = 0;
      currentScaleValue = 1;
      
      const orb = document.getElementById('orb');
      orb.classList.remove('scaling');
      orb.style.removeProperty('--target-scale');
      
      // Если фокус — плавная анимация B→A как при включении
      if (document.body.classList.contains('focus-mode') && originalOrbParent) {
        // Временно показать orb-shell чтобы получить актуальные координаты
        const shell = document.querySelector('.orb-shell');
        const wasHidden = shell.style.display === 'none' || shell.style.visibility === 'hidden';
        
        // Временно показать для измерения
        if (wasHidden) {
          shell.style.visibility = 'visible';
          shell.style.opacity = '0'; // невидимо, но измеримо
        }
        
        const sr = shell.getBoundingClientRect();
        const finalX = sr.left + sr.width / 2; // актуальная точка A
        const finalY = sr.top + sr.height / 2;
        
        // Вернуть скрытие если было
        if (wasHidden) {
          shell.style.visibility = '';
          shell.style.opacity = '';
        }
        
        // Отладка: проверяем координаты
        console.log('Stop breathing - actualX:', finalX, 'actualY:', finalY, 'savedX:', focusStartX, 'savedY:', focusStartY);
        console.log('🎬 STOP ANIMATION: B→A from center to', finalX, finalY);
        
        // Получаем текущую позицию и размер круга
        const currentRect = orb.getBoundingClientRect();
        const currentX = currentRect.left + currentRect.width / 2;
        const currentY = currentRect.top + currentRect.height / 2;
        console.log('🎬 CURRENT ORB POSITION:', currentX, currentY);
        console.log('📏 STOP: Current orb size:', currentRect.width + 'px x ' + currentRect.height + 'px');
        console.log('📏 STOP: Current orb CSS size:', orb.style.width, 'x', orb.style.height);
        
        // Простая анимация напрямую к точке A (как при включении, но наоборот)
        orb.style.willChange = 'top, left, transform, width, height, opacity';
        orb.style.transition = `top ${FOCUS_MOVE_MS}ms ease-out, left ${FOCUS_MOVE_MS}ms ease-out, transform ${FOCUS_MOVE_MS}ms ease-out, width ${FOCUS_MOVE_MS}ms ease-out, height ${FOCUS_MOVE_MS}ms ease-out, opacity ${FOCUS_MOVE_MS}ms ease-out`;
        
        // Добавляем визуальный эффект "возврата"
        orb.style.transform = 'translate(-50%, -50%) scale(0.9)'; // Сначала немного уменьшаем
        orb.style.opacity = '0.8'; // Делаем немного полупрозрачным
        console.log('🎬 SETTING STOP TRANSITION:', orb.style.transition);
        
        // Анимируем к точке A
        requestAnimationFrame(() => {
          console.log('🎬 TRIGGERING STOP ANIMATION to', finalX, finalY, '+ size decrease');
          orb.style.top = `${finalY}px`;
          orb.style.left = `${finalX}px`;
          // Определяем размер в зависимости от экрана
          const isMobile = window.innerWidth <= 768;
          const normalSize = isMobile ? '150px' : '200px';
          
          orb.style.width = normalSize; // Уменьшаем размер обратно
          orb.style.height = normalSize;
          console.log('📏 STOP: Animating orb size to', normalSize, '(back to normal size)');
          orb.style.transform = 'translate(-50%, -50%) scale(1)'; // Возвращаем размер
          orb.style.opacity = '1'; // Возвращаем непрозрачность
        });
        
        // Обработчик завершения анимации
        const onReturnComplete = () => {
          console.log('Return animation complete, returning to DOM');
          logTextPosition('BEFORE RETURNING TO DOM');
          
          // СНАЧАЛА возвращаем в DOM, сохраняя position: fixed
          console.log('🔄 MOVING ORB BACK TO ORIGINAL DOM PARENT');
          if (originalOrbNextSibling) {
            originalOrbParent.insertBefore(orb, originalOrbNextSibling);
          } else {
            originalOrbParent.appendChild(orb);
          }
          logTextPosition('AFTER MOVING TO ORIGINAL PARENT');
          
          // Завершить фокус-режим (уберёт фон/частицы) СРАЗУ
          exitFocusMode();
          
          // ПОТОМ через микротаск очищаем стили позиционирования
          requestAnimationFrame(() => {
            console.log('📏 CLEANUP: Before clearing - orb size:', orb.getBoundingClientRect().width + 'px x ' + orb.getBoundingClientRect().height + 'px');
            console.log('📏 CLEANUP: Before clearing - CSS size:', orb.style.width, 'x', orb.style.height);
            
            orb.style.position = '';
            orb.style.top = '';
            orb.style.left = '';
            // НЕ очищаем размер - оставляем правильный размер!
            // orb.style.width = ''; // Не очищаем размер
            // orb.style.height = ''; // Не очищаем размер
            orb.style.opacity = ''; // Очищаем прозрачность
            orb.style.willChange = 'auto';
            orb.style.transition = 'transform 0.25s ease';
            orb.style.transform = 'scale(1)';
            
            console.log('📏 CLEANUP: After NOT clearing size - orb size:', orb.getBoundingClientRect().width + 'px x ' + orb.getBoundingClientRect().height + 'px');
            console.log('📏 CLEANUP: After NOT clearing size - CSS size:', orb.style.width, 'x', orb.style.height);
            console.log('Styles cleared (but size preserved)');
            logTextPosition('AFTER CLEANUP');
          });
        };
        
        // Обработчик с фоллбеком
        const timeoutId = setTimeout(() => {
          console.log('🎬 STOP ANIMATION TIMEOUT FALLBACK triggered after', FOCUS_MOVE_MS + 100, 'ms');
          onReturnComplete();
        }, FOCUS_MOVE_MS + 100);
        
        const onceHandler = (e) => { 
          console.log('🎬 STOP ANIMATION TRANSITIONEND triggered:', e.propertyName);
          clearTimeout(timeoutId); 
          onReturnComplete(); 
        };
        orb.addEventListener('transitionend', onceHandler, { once: true });
      } else {
        // Обычный режим — просто вернуть масштаб
        orb.style.transition = 'transform 0.25s ease';
        orb.style.transform = 'scale(1)';
      }
      
      // Reset phase text
      const phaseElement = document.getElementById('phase');
      if (phaseElement) {
        phaseElement.textContent = 'Готовы?';
      }
      
      const timeLeftElement = document.getElementById('timeLeft');
      if (timeLeftElement) {
        timeLeftElement.textContent = '00:00';
      }
      
      // Update stop button visibility
      const stopButton = document.getElementById('stopBreath');
      if (stopButton) {
        stopButton.style.display = 'none';
      }
      
      // Останавливаем музыку при остановке упражнения
      stopMusic();
      
      // Освобождаем wake lock
      releaseWakeLock();
    }
    
    // ================ MUSIC MANAGEMENT ================
    function initMusic() {
      if (backgroundMusic) return; // Already initialized
      
      try {
        backgroundMusic = new Audio('./none.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = musicVolume;
        backgroundMusic.preload = 'auto';
      } catch (error) {
        console.error('❌ Failed to initialize music:', error);
      }
    }
    
    function startMusic() {
      if (!backgroundMusic) {
        initMusic();
      }
      
      if (backgroundMusic && document.getElementById('musicToggle').checked) {
        try {
          backgroundMusic.volume = musicVolume;
          backgroundMusic.play().catch(error => {
            console.error('❌ Failed to play music:', error);
          });
        } catch (error) {
          console.error('❌ Error starting music:', error);
        }
      }
    }
    
    function stopMusic() {
      if (backgroundMusic) {
        try {
          backgroundMusic.pause();
          backgroundMusic.currentTime = 0;
        } catch (error) {
          console.error('❌ Error stopping music:', error);
        }
      }
    }
    
    function updateMusicVolume(volume) {
      musicVolume = volume / 100;
      if (backgroundMusic) {
        backgroundMusic.volume = musicVolume;
      }
    }
    
    // Screen wake lock functions
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('🔒 Screen wake lock activated');
        }
      } catch (error) {
        console.log('⚠️ Wake lock not supported or failed:', error);
      }
    }
    
    function releaseWakeLock() {
      if (wakeLock) {
        try {
          wakeLock.release();
          wakeLock = null;
          console.log('🔓 Screen wake lock released');
        } catch (error) {
          console.log('⚠️ Error releasing wake lock:', error);
        }
      }
    }
    
    // ================ PARTICLES (focus breath effect) ================
    const PARTICLE_COUNT = 350; // Увеличиваем количество частиц для более плавного движения
    let particles = [];
    function initParticles() {
      particles = Array.from({ length: PARTICLE_COUNT }).map((_, i) => {
        // Более равномерное распределение частиц по экрану
        const gridSize = Math.ceil(Math.sqrt(PARTICLE_COUNT));
        const cellWidth = window.innerWidth / gridSize;
        const cellHeight = window.innerHeight / gridSize;
        
        const gridX = i % gridSize;
        const gridY = Math.floor(i / gridSize);
        
        const particle = {
          x: (gridX * cellWidth) + (Math.random() * cellWidth * 0.8) + (cellWidth * 0.1),
          y: (gridY * cellHeight) + (Math.random() * cellHeight * 0.8) + (cellHeight * 0.1),
          originalX: 0, // Будет установлено ниже
          originalY: 0, // Будет установлено ниже
          vx: (Math.random() - 0.5) * 0.5, // Начальная случайная скорость
          vy: (Math.random() - 0.5) * 0.5,
          size: 1 + Math.random() * 2.5, // Немного уменьшаем размер
          alpha: 0.3 + Math.random() * 0.4 // Увеличиваем прозрачность
        };
        
        // Сохраняем исходные позиции для возврата
        particle.originalX = particle.x;
        particle.originalY = particle.y;
        
        return particle;
      });
    }
    
    function startParticles() {
      // Проверяем, существует ли canvas
      if (!particlesCanvas) {
        createParticlesCanvas();
      }
      
      // Проверяем, что canvas в DOM
      if (!particlesCanvas.parentNode) {
        document.body.appendChild(particlesCanvas);
      }
      
      // Показываем canvas если он скрыт
      if (particlesCanvas.style.display === 'none') {
        particlesCanvas.style.display = '';
        particlesCanvas.style.opacity = '1';
      }
      
      if (!particlesCanvas) {
        return;
      }
      
      // Проверяем, есть ли уже частицы с исходными позициями
      const hasExistingParticles = particles.length > 0 && particles.every(p => p.originalX !== undefined && p.originalY !== undefined);
      
      if (hasExistingParticles) {
        // Сбрасываем позиции частиц на исходные, но сохраняем originalX/originalY
        particles.forEach(p => {
          p.x = p.originalX;
          p.y = p.originalY;
          p.vx = (Math.random() - 0.5) * 0.5;
          p.vy = (Math.random() - 0.5) * 0.5;
        });
      } else {
        initParticles();
      }
      
      cancelAnimationFrame(particlesAnim);
      
      let frameCount = 0;
      function tick() {
        frameCount++;
        
        particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
        
        for (const p of particles) {
          // move
          p.x += p.vx;
          p.y += p.vy;
          
          // target behavior by current mode
          const cx = window.innerWidth / 2;
          const cy = window.innerHeight / 2;
          const dx = cx - p.x;
          const dy = cy - p.y;
          const dist = Math.hypot(dx, dy) + 0.001;
          const ux = dx / dist;
          const uy = dy / dist;
          
          if (particlesMode === 'inhale') {
            // При вдохе: частицы очень медленно стремятся к центру
            const inhaleForce = 0.05; // Еще больше уменьшаем силу
            p.vx += ux * inhaleForce;
            p.vy += uy * inhaleForce;
            
            // Ограничиваем максимальную скорость
            const maxSpeed = 0.8; // Еще больше уменьшаем максимальную скорость
            const currentSpeed = Math.hypot(p.vx, p.vy);
            if (currentSpeed > maxSpeed) {
              p.vx = (p.vx / currentSpeed) * maxSpeed;
              p.vy = (p.vy / currentSpeed) * maxSpeed;
            }
            
          } else if (particlesMode === 'exhale') {
            // При выдохе: частицы постепенно возвращаются на исходные позиции
            const exhaleForce = 0.03; // Очень слабая сила для плавного возврата
            
            // Вычисляем направление к исходной позиции
            const dx = p.originalX - p.x;
            const dy = p.originalY - p.y;
            const dist = Math.hypot(dx, dy) + 0.001;
            const returnUx = dx / dist;
            const returnUy = dy / dist;
            
            // Плавно возвращаем частицы к исходным позициям
            p.vx += returnUx * exhaleForce;
            p.vy += returnUy * exhaleForce;
            
            // Ограничиваем максимальную скорость
            const maxSpeed = 0.6; // Очень медленное движение
            const currentSpeed = Math.hypot(p.vx, p.vy);
            if (currentSpeed > maxSpeed) {
              p.vx = (p.vx / currentSpeed) * maxSpeed;
              p.vy = (p.vy / currentSpeed) * maxSpeed;
            }
            
          } else if (particlesMode === 'hold') {
            // При задержке: частицы плавно замирают
            p.vx *= 0.85; // Более плавное замедление
            p.vy *= 0.85;
            
          } else {
            // В режиме ожидания: очень легкое замедление
            p.vx *= 0.99; // Минимальное трение
            p.vy *= 0.99;
          }
          
          // Общее трение для всех режимов
          p.vx *= 0.995; // Уменьшаем трение для более плавного движения
          p.vy *= 0.995;
          
          // draw
          particlesCtx.fillStyle = `rgba(255,255,255,${p.alpha})`;
          particlesCtx.beginPath();
          particlesCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          particlesCtx.fill();
          
          // bounds wrap - частицы появляются с противоположной стороны
          if (p.x < 0) p.x = particlesCanvas.width;
          if (p.x > particlesCanvas.width) p.x = 0;
          if (p.y < 0) p.y = particlesCanvas.height;
          if (p.y > particlesCanvas.height) p.y = 0;
        }
        particlesAnim = requestAnimationFrame(tick);
      }
      tick();
    }
    
    function stopParticles() {
      cancelAnimationFrame(particlesAnim);
      
      if (particlesCanvas && particlesCanvas.parentNode) {
        // Анимация возврата частиц на исходные позиции
        let returnFrameCount = 0;
        const returnDuration = 120; // 2 секунды при 60 FPS для более плавного возврата
        
        function returnTick() {
          returnFrameCount++;
          
          particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
          

          
          let allReturned = true;
          let totalDistance = 0;
          
          for (const p of particles) {
            // Плавно возвращаем частицы к исходным позициям
            const progress = returnFrameCount / returnDuration;
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Плавное замедление
            
            // Интерполируем между текущей и исходной позицией
            const oldX = p.x;
            const oldY = p.y;
            p.x = p.x + (p.originalX - p.x) * easeProgress * 0.05; // Уменьшаем скорость возврата
            p.y = p.y + (p.originalY - p.y) * easeProgress * 0.05;
            
            // Замедляем скорость
            p.vx *= 0.95;
            p.vy *= 0.95;
            
            // Рисуем частицу
            particlesCtx.fillStyle = `rgba(255,255,255,${p.alpha * (1 - progress * 0.5)})`;
            particlesCtx.beginPath();
            particlesCtx.arc(p.x, p.y, p.size * (1 - progress * 0.3), 0, Math.PI * 2);
            particlesCtx.fill();
            
            // Проверяем, вернулись ли все частицы
            const distance = Math.hypot(p.x - p.originalX, p.y - p.originalY);
            totalDistance += distance;
            if (distance > 2) allReturned = false;
          }
          

          
          if (returnFrameCount < returnDuration && !allReturned) {
            requestAnimationFrame(returnTick);
          } else {
            // Теперь плавно исчезаем, но НЕ удаляем canvas
            particlesCanvas.style.transition = 'opacity 0.4s ease';
            particlesCanvas.style.opacity = '0';
            
            setTimeout(() => {
              if (particlesCanvas && particlesCanvas.parentNode) {
                // Просто скрываем canvas, но не удаляем его
                particlesCanvas.style.display = 'none';
              }
            }, 400);
          }
        }
        
        returnTick();
      }
    }
    
    function updateParticlesForPhase(phase, duration) {
      if (!particlesCanvas) {
        return;
      }
      
      const oldMode = particlesMode;
      if (phase === 'inhale') particlesMode = 'inhale';
      else if (phase === 'exhale') particlesMode = 'exhale';
      else if (phase === 'hold' || phase === 'pause') particlesMode = 'hold';
      else particlesMode = 'idle';
    }
    
    // Focus mode functions
    let focusPortal = null;
    let originalOrbParent = null;
    let originalOrbNextSibling = null;
    let originalBackdropParent = null;
    let originalBackdropNextSibling = null;
    
    function createParticlesCanvas() {
      particlesCanvas = document.createElement('canvas');
      particlesCanvas.width = window.innerWidth;
      particlesCanvas.height = window.innerHeight;
      particlesCanvas.style.position = 'fixed';
      particlesCanvas.style.inset = '0';
      particlesCanvas.style.zIndex = '1';
      particlesCanvas.style.pointerEvents = 'none';
      particlesCtx = particlesCanvas.getContext('2d');
    }
    
    function enterFocusMode() {
      if (document.body.classList.contains('focus-mode')) return;
      console.log('🎭 ENTERING FOCUS MODE - hiding UI elements');
      logTextPosition('BEFORE FOCUS MODE');
      document.body.classList.add('focus-mode');
      
      // Логируем после небольшой задержки, чтобы CSS успел примениться
      setTimeout(() => {
        logTextPosition('AFTER FOCUS MODE APPLIED');
      }, 50);
      
      const orb = document.getElementById('orb');
      const backdrop = null; // backdrop removed
      const grad = document.getElementById('focusGradient');
      
      // Save original positions
      originalOrbParent = orb.parentNode;
      originalOrbNextSibling = orb.nextSibling;
      originalBackdropParent = null;
      originalBackdropNextSibling = null;
      
      // Create portal layer if not exists
      if (!focusPortal) {
        focusPortal = document.createElement('div');
        focusPortal.id = 'focus-portal';
        focusPortal.style.position = 'fixed';
        focusPortal.style.inset = '0';
        focusPortal.style.zIndex = '99990';
        focusPortal.style.pointerEvents = 'none';
        document.body.appendChild(focusPortal);
      }
      
      // Move gradient and orb to portal (keep click on orb enabled)
      if (grad) {
        grad.style.opacity = '1';
        focusPortal.appendChild(grad);
      }
      console.log('🚀 MOVING ORB TO FOCUS PORTAL');
      console.log('  Before moving - orb position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      console.log('  Before moving - getBoundingClientRect:', orb.getBoundingClientRect().left + ',' + orb.getBoundingClientRect().top);
      
      focusPortal.appendChild(orb);
      
      console.log('  After moving to portal - orb parent:', orb.parentNode.id);
      
      orb.style.pointerEvents = 'auto';
      
      // Проверяем позицию после перемещения
      setTimeout(() => {
        const rect = orb.getBoundingClientRect();
        console.log('  🔍 AFTER MOVING - getBoundingClientRect:', Math.round(rect.left) + ',' + Math.round(rect.top));
        console.log('  🔍 AFTER MOVING - CSS styles:', 'position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      }, 10);
      
      logTextPosition('AFTER MOVING TO FOCUS PORTAL');

      // create particles canvas once
      if (!particlesCanvas) {
        createParticlesCanvas();
      }
      
      focusPortal.insertBefore(particlesCanvas, orb);
      startParticles();
    }
    
    function exitFocusMode() {
      if (!document.body.classList.contains('focus-mode')) return;
      console.log('🎭 EXITING FOCUS MODE - showing UI elements with staggered animation');
      const orb = document.getElementById('orb');
      const backdrop = null;
      const grad = document.getElementById('focusGradient');
      
      // Return nodes back to their original containers
      // no backdrop
      if (grad && originalOrbParent) {
        console.log('🎨 FADING OUT FOCUS GRADIENT');
        grad.style.opacity = '0'; // Начинаем плавное исчезновение
        
        // Перемещаем обратно в DOM, но даем время для анимации
        setTimeout(() => {
          console.log('🎨 MOVING FOCUS GRADIENT BACK TO ORIGINAL POSITION');
          originalOrbParent.insertBefore(grad, originalOrbParent.firstChild);
        }, 600); // Ждем завершения анимации opacity (0.6s)
      }
      stopParticles();
      
      console.log('🔄 MOVING ORB BACK TO ORIGINAL DOM PARENT');
      console.log('  Before moving back - orb position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      console.log('  Before moving back - getBoundingClientRect:', orb.getBoundingClientRect().left + ',' + orb.getBoundingClientRect().top);
      console.log('  Target parent:', originalOrbParent.id || originalOrbParent.className);
      
      if (originalOrbParent) {
        if (originalOrbNextSibling) {
          originalOrbParent.insertBefore(orb, originalOrbNextSibling);
        } else {
          originalOrbParent.appendChild(orb);
        }
      }
      
      console.log('  After moving back - orb parent:', orb.parentNode.id || orb.parentNode.className);
      
      // Проверяем позицию после возврата
      setTimeout(() => {
        const rect = orb.getBoundingClientRect();
        console.log('  🔍 AFTER MOVING BACK - getBoundingClientRect:', Math.round(rect.left) + ',' + Math.round(rect.top));
        console.log('  🔍 AFTER MOVING BACK - CSS styles:', 'position:', orb.style.position, 'top:', orb.style.top, 'left:', orb.style.left);
      }, 10);
      
      // Reset styles for normal mode
      orb.style.pointerEvents = '';
      orb.classList.remove('scaling');
      orb.style.removeProperty('--phase-duration');
      orb.style.removeProperty('--target-scale');
      orb.style.transition = 'transform 0.5s ease-in-out';
      orb.style.transform = 'scale(1)';
      
      // Убираем класс focus-mode с небольшой задержкой, чтобы градиент успел исчезнуть
      setTimeout(() => {
        document.body.classList.remove('focus-mode');
        console.log('🎭 FOCUS MODE CLASS REMOVED - UI elements should now animate in');
        
        // КРИТИЧНО: Сразу очищаем позиционирование орба после снятия focus-mode
        const orb = document.getElementById('orb');
        if (orb && orb.style.position !== 'fixed') {
          console.log('🧹 EMERGENCY CLEANUP: Clearing orb positioning after focus-mode removal');
          console.log('  Before cleanup - top:', orb.style.top, 'left:', orb.style.left, 'position:', orb.style.position);
          orb.style.position = '';
          orb.style.top = '';
          orb.style.left = '';
          console.log('  After cleanup - top:', orb.style.top, 'left:', orb.style.left, 'position:', orb.style.position);
        }
        
        // Логируем после снятия focus-mode
        setTimeout(() => {
          logTextPosition('AFTER FOCUS MODE REMOVED');
        }, 50);
      }, 300); // Даем градиенту время начать исчезать
    }
    

    
    // ================= JOURNAL LOGIC =================
    function saveEntry() {
      const stressLevel = document.getElementById('stressLevel').value;
      const note = document.getElementById('note').value;
      
      if (!note.trim()) {
        alert('Пожалуйста, добавьте заметку');
        return;
      }
      
      const entry = {
        id: Date.now(),
        date: new Date().toISOString(),
        stressLevel: parseInt(stressLevel),
        note: note.trim()
      };
      
      // Get existing entries
      const entries = JSON.parse(localStorage.getItem('journalEntries') || '[]');
      entries.unshift(entry);
      
      // Save to localStorage
      localStorage.setItem('journalEntries', JSON.stringify(entries));
      
      // Clear form
      document.getElementById('note').value = '';
      document.getElementById('stressLevel').value = 5;
      document.getElementById('stressLevelLabel').textContent = '5';
      
      // Refresh display
      renderEntries();
      
      alert('Запись сохранена!');
    }
    
    function renderEntries() {
      const entries = JSON.parse(localStorage.getItem('journalEntries') || '[]');
      const entriesList = document.getElementById('entries');
      
      if (entries.length === 0) {
        entriesList.innerHTML = '<li class="list-item"><div class="list-item-title">Пока нет записей</div></li>';
        return;
      }
      
      entriesList.innerHTML = entries.map(entry => {
        const date = new Date(entry.date).toLocaleDateString('ru-RU');
        return `
          <li class="list-item">
            <div class="list-item-title">${date} - Уровень ${entry.stressLevel}/10</div>
            <div class="list-item-subtitle">${entry.note}</div>
          </li>
        `;
      }).join('');
    }
    
    function clearEntries() {
      if (confirm('Удалить все записи?')) {
        localStorage.removeItem('journalEntries');
        renderEntries();
        alert('Все записи удалены');
      }
    }
    
    // ================= SETTINGS LOGIC =================
    function loadSettings() {
      const settings = JSON.parse(localStorage.getItem('settings') || '{}');
      
      if (settings.vibration !== undefined) {
        document.getElementById('vibrationToggle').checked = settings.vibration;
      }
      
      if (settings.voice !== undefined) {
        document.getElementById('voiceToggle').checked = settings.voice;
      }
      
      if (settings.music !== undefined) {
        const musicToggle = document.getElementById('musicToggle');
        musicToggle.checked = settings.music;
        const volumeControl = document.getElementById('volumeControl');
        if (settings.music) {
          volumeControl.style.display = 'block';
        }
      }
      
      if (settings.volume !== undefined) {
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeLabel = document.getElementById('volumeLabel');
        volumeSlider.value = settings.volume;
        volumeLabel.textContent = settings.volume + '%';
        musicVolume = settings.volume / 100;
      }
      
      if (settings.theme) {
        const themeSelect = document.getElementById('themeSelect');
        if (themeSelect) {
          themeSelect.value = settings.theme;
          // Не вызываем applyTheme здесь, так как DOM может быть не готов
        }
      }
      
      if (settings.language) {
        const langSelect = document.getElementById('langSelect');
        if (langSelect) {
          langSelect.value = settings.language;
          // Не вызываем setLanguage здесь, так как DOM может быть не готов
          currentLang = settings.language;
        }
      }
    }
    
    function saveSettings() {
      const settings = {
        vibration: document.getElementById('vibrationToggle').checked,
        voice: document.getElementById('voiceToggle').checked,
        music: document.getElementById('musicToggle').checked,
        volume: document.getElementById('volumeSlider').value,
        theme: document.getElementById('themeSelect').value,
        language: document.getElementById('langSelect').value
      };
      
      localStorage.setItem('settings', JSON.stringify(settings));
      
      // Apply theme
      applyTheme(settings.theme);
      
      // Apply language
      setLanguage(settings.language);
    }
    
    function applyTheme(theme) {
      if (theme === 'auto') {
        document.documentElement.removeAttribute('data-theme');
      } else {
        document.documentElement.setAttribute('data-theme', theme);
      }
    }
    
    // ================= NAVIGATION =================
    function showTab(tabName) {
      // Hide all pages
      document.querySelectorAll('.page').forEach(page => {
        page.classList.remove('active');
      });
      
      // Show selected page
      document.getElementById(tabName).classList.add('active');
      
      // Update navigation
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      
      // Update page title
      const pageTitles = {
        'breath': I18N[currentLang].tabs.breath,
        'journal': I18N[currentLang].tabs.journal,
        'settings': I18N[currentLang].tabs.settings
      };
      
      document.getElementById('pageTitle').textContent = pageTitles[tabName];
    }
    
    // ================= EVENT LISTENERS =================
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize
      loadSettings();
      renderEntries();
      buildModeOptions();
      
      // Navigation
      document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          e.preventDefault();
          const tabName = tab.getAttribute('data-tab');
          showTab(tabName);
        });
      });
      
      // Breathing controls
      document.getElementById('stopBreath').addEventListener('click', stopBreathing);
      
      // Orb click to start/stop
      document.getElementById('orb').addEventListener('click', function() {
        if (currentPhase === 'ready') {
          startBreathing();
        } else {
          stopBreathing();
        }
      });
      
      // Journal controls
      document.getElementById('saveEntry').addEventListener('click', saveEntry);
      document.getElementById('clearEntries').addEventListener('click', clearEntries);
      
      // Settings controls
      document.getElementById('vibrationToggle').addEventListener('change', saveSettings);
      document.getElementById('voiceToggle').addEventListener('change', saveSettings);
      document.getElementById('musicToggle').addEventListener('change', function() {
        const volumeControl = document.getElementById('volumeControl');
        if (this.checked) {
          volumeControl.style.display = 'block';
          initMusic();
        } else {
          volumeControl.style.display = 'none';
          stopMusic();
        }
        saveSettings();
      });
      document.getElementById('volumeSlider').addEventListener('input', function() {
        const volumeLabel = document.getElementById('volumeLabel');
        volumeLabel.textContent = this.value + '%';
        updateMusicVolume(this.value);
        saveSettings();
      });
      document.getElementById('themeSelect').addEventListener('change', saveSettings);
      document.getElementById('langSelect').addEventListener('change', saveSettings);
      
      // Mode change
      document.getElementById('mode').addEventListener('change', updateModeInfo);
      
      // Stress level slider
      document.getElementById('stressLevel').addEventListener('input', function() {
        document.getElementById('stressLevelLabel').textContent = this.value;
      });
      
      // Minutes slider
      document.getElementById('minutes').addEventListener('input', function() {
        document.getElementById('minutesLabel').textContent = this.value;
      });
      
      // Prevent zoom
      document.addEventListener('gesturestart', e => e.preventDefault());
      document.addEventListener('gesturechange', e => e.preventDefault());
      document.addEventListener('gestureend', e => e.preventDefault());
      
      let lastTouchEnd = 0;
      document.addEventListener('touchend', function(event) {
        const now = (new Date()).getTime();
        if (now - lastTouchEnd <= 300) {
          event.preventDefault();
        }
        lastTouchEnd = now;
      }, false);
    });
    
    // PWA Service Worker Registration (only for HTTP/HTTPS)
    if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then((registration) => {
            console.log('SW registered: ', registration);
          })
          .catch((registrationError) => {
            console.log('SW registration failed: ', registrationError);
          });
      });
    }
  </script>
</body>
</html>


